Simulating Altera memories in ModelSim
To simulate with ModelSim, you will need to include the altera_mf_ver library (under the Libraries tab) when you start simulation. If you are using the tcl shell instead of clicking around, use the -L option to vsim, like in this example:

vsim -L altera_mf_ver work.tb_task1
For netlist simulation, you will also need cyclonev_ver, altera_ver, and altera_lnsim_ver.

To make ModelSim happy about how many picoseconds each #-tick is, you will have to add

`timescale 1ps / 1ps
at the beginning of your RTL files and testbench files.

Examining memory contents when simulating RTL in Modelsim
You might find ModelSim's memory viewer (accessible from View→Memory List) helpful here; it will list all the memories in the design and allow you to examine any of them. It might be useful to change the radix to hex (right-click on the memory contents view and select Properties).

In your RTL testbench, you can access the memory from your testbench using the dot notation:

dut.s.altsyncram_component.m_default.altsyncram_inst.mem_data
(assuming you named your task1 instance dut inside your testbench). Note that the dot notation may be used only in your testbench, not in anything you wish to synthesize.

If you decide to initialize the memory in one of your testbenches in an initial block, be sure to do this after a delay (e.g., #10); otherwise your initialization will end up in a race condition with the Altera memory model and its own initial block.

Examining memory contents when simulating a netlist in Modelsim
In a post-synthesis netlist, your design will have been flattened into a sea of primitive FPGA components. So what happens with the memories and the lovely hierarchical path that allowed us to access the contents?

The good news is that the memories survive somewhere inside your netlist, and the primitive memory blocks are modelled as Verilog memory arrays like the RTL models. This means that we can examine them from the Memory List tab and use Verilog array notation or $readmemh and friends to fill them (see below).

The name also survives, albeit in a horribly mangled form. Once you complete Task 1, look at the post-synthesis netlist file task1.vo from Task 1 and look for cyclonev_ram_block. You should see one instance:

cyclonev_ram_block \s|altsyncram_component|auto_generated|altsyncram1|ram_block3a0 (
    .portawe(!count[8]),
    .portare(vcc),
    .portaaddrstall(gnd),
    .portbwe(\s|altsyncram_component|auto_generated|mgl_prim2|enable_write~0_combout ),
    .portbre(vcc),
    ...
Note the space before the opening bracket: it's actually part of the identifier syntax, not just a meaningless space. The \ and the space delineate an escaped identifier in SystemVerilog, and you have to include the space in the middle of the hierarchical name if you want to access the array inside:

dut.\s|altsyncram_component|auto_generated|altsyncram1|ram_block3a0 .ram_core0.ram_core0.mem
The space is still there — looks weird, but that's how things work in SystemVerilog.

Initializing memory contents in simulation
In your testbench, you will likely want to use $readmemh() to initialize memories and compare them to a known reference state. You can look up how $readmemh() works in the SystemVerilog 2017 Language Standard posted with the course documents. If you read any external files in your testbench, you will have to commit them in the same folder as the testbench that uses them, as the autograder will not try to guess where you might have put them.